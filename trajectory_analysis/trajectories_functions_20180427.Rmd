---
title: "Herders - Functions for the Trajectories Data Analysis"
author: "Christian Knoth, Henning Teickner"
date: "27 April 2018"
output: 
  html_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
<style>
body {
text-align: justify}
</style>

# Introduction

Definition of the workspace
```{r workspace_definition, eval = T, message = F, warning = F}
# define directory to obtain data from
# directory.data = "C:/Herders/trajectories/"
```

Load required packages
```{r load_packages, eval = T, message = F, warning = F}
# load packages
require(sp)
require(spacetime)
require(trajectories)
library(rgl)
library(rglwidget)
library(mapview)
library(xts)
library(lubridate)
library(spatstat)
library(rgeos)
library(maptools)

```

# Functions

## readTrack

Function in order to import an individual GPS track file.

* Arguments:
    + `fname`: file name of the correpsonding GPS track file.

* Value:
    + An object of class `Track`.

```{r readTrack, eval = T, message = F, warning = F}
readTrack = function(fname) {
  dt2POSIX = function(dt, tm) {
    stopifnot(is.numeric(dt) && is.numeric(tm))
    as.POSIXct(paste0(
      2000 + dt %/% 10000, "-",
      (dt %/% 100) %% 100, "-",
      dt %% 100, " ",
      tm %/% 10000, ":",
      tm %/% 100 %% 100, ":",
      tm %% 100), tz ="GMT")
  }
  print(paste("reading file", fname))
  x = read.csv(fname, skipNul = TRUE) # most files contain embedded nuls
  x = x[!is.na(x$DATE),]
  x$lat = as.numeric(sub("N", "", x$LATITUDE.N.S))
  x$lon = x$LONGITUDE.E.W
  tm = dt2POSIX(x$DATE, x$TIME)
  pts = SpatialPoints(cbind(x$lon, x$lat), CRS("+proj=longlat +ellps=WGS84"))
  st = STIDF(pts, tm, x)
  Track(st)
}
```

## removeEmptyFiles

Function in order to remove empty csv tables.

* Arguments:
    + `listname`: a list of file names of the correpsonding GPS track files that should be chekced.

```{r removeEmptyFiles, eval = T, message = F, warning = F}
removeEmptyFiles = function(listname){
  remove = character()
  checkFile = function(fname){
    if (file.size(fname) == 0){
      append(remove,fname)
    } else{
      append(remove,NA)
    }
    
  }
  remove = lapply(listname,checkFile)
  remove = remove[!is.na(remove)]
  print("Ignoring empty files:", quote=F)
  print(paste(remove), print.na = "", quote=F)
  listname[! listname %in% remove]
}
```

## removeEmptyFolders

Function in order to remove empty folders.

* Arguments:
    + `listname`: a list of folder names that should be checked.

```{r removeEmptyFolders, eval = T, message = F, warning = F}
removeEmptyFolders = function(dirlist){
  remove = character()
  checkDir = function(dirname){
    if (length(list.files(dirname, pattern="*.CSV", full.names = T)) == 0){
      append(remove,dirname)
    } else{
      append(remove,NA)
    }
    
  }
  remove = lapply(dirlist,checkDir)
  remove = remove[!is.na(remove)]
  print("Ignoring empty folders:", quote=F)
  print(paste(remove), print.na = "", quote=F)
  dirlist[! dirlist %in% remove]
}
```

## loadTracks

Function in order to load all GPS track data within a specified directory. The function also removes empty csv tables within the folders by calling the function `removeEmptyFiles`.

* Arguments:
    + `folder`: path to a folder with csv data.

* Value:
    + An object of class `Tracks`.

```{r loadTracks, eval = T, message = F, warning = F}
loadTracks = function(folder) {
  print(paste("Loading tracks from folder", folder, sep = " "),quote = F)
  lst = list.files(folder, pattern = "*.CSV", full.names = T)
  lst = removeEmptyFiles(lst)
  Tracks(lapply(lst, readTrack))
}
```

## timeActiveTrack

Function in order to compute the time [s] during which position data was collected in a given `Track` object (for an individual `Track` object) within a given time frame.

* Arguments:
    + `currenttrack`: A `Track` object.
    + `tstart`: a POSIXct object indicating the date and time of the start of the target period.
    + `tend`: a POSIXct object indicating the date and time of the end of the target period.
    
* Value:
    + 0: If the `Track` object does not cover any value of the target period.
    + 1: If the maximum time value of the `Track` object equals the start value of the target period or if the minimum time value of the `Track` object equals the end value of the target period.
    + numeric: The number of seconds between the first entry of the `Track` object within the time period and the last entry of the `Track` object within the time period.

```{r timeActiveTrack, eval = T, message = F, warning = F}
timeActiveTrack <- function(currenttrack, tstart, tend) {
  if (max(index(currenttrack@time)) < tstart |
      min(index(currenttrack@time)) > tend) {
    #if currenttrack is completely outside the given timeframe return 0
    0
  }
  else if (max(index(currenttrack@time)) == tstart |
           min(index(currenttrack@time)) == tend) {
    #if currenttrack touches the time frame (e.g. last fix of track equals start of time frame) return 1
    # to show there is a fix in the given time frame
    1
  }
  else{
    as.double(difftime(max(index(
      currenttrack@time
    )[index(currenttrack@time) <= tend]),
    min(index(
      currenttrack@time
    )[index(currenttrack@time) >= tstart]), units =
      "sec"))
  }
}
```

## timeActiveTracks

Function in order to compute the time [s] during which position data was collected in a given `Track` object (for all `Track` objects within this `Tracks` object) within a given time frame by means of the function `timeActiveTrack` (yields the total time during which the logger of a given household was active).

* Arguments:
    + `currenttracks`: A `Tracks` object.
    + `tstart`: a POSIXct object indicating the date and time of the start of the target period.
    + `tend`: a POSIXct object indicating the date and time of the end of the target period.
    
* Value:
    + numeric: The sum of the number of seconds between the first entry of a `Track` object within the time period and the last entry of the same `Track` object within the time period for all `Track` objects within the `Tracks` object.

```{r timeActiveTracks, eval = T, message = F, warning = F}
timeActiveTracks <- function(currenttracks, tstart, tend){
  sum(unlist(
    lapply(
      currenttracks@tracks,
      timeActiveTrack,
      tstart = tstart,
      tend = tend
    )
  ))
}
```

## timeActiveTracksCollection

Function in order to compute the time [s] during which position data was collected in a given `Track` object (for all `Track` objects within this `Tracks` object) within a given time frame by means of the function `timeActiveTrack` (yields the total time during which the logger of a given household was active).

* Arguments:
    + `trcollection`: A `TracksCollection` object.
    + `timeframe`: A list with the following entries:
        + `tstart`: a POSIXct object indicating the date and time of the start of the target period.
        + `tend`: a POSIXct object indicating the date and time of the end of the target period.
    
* Value:
    + numeric: The proportion of the sum of the number of seconds between the first entry of a `Track` object within the time period and the last entry of the same `Track` object within the time period for all `Track` objects within the `TrackCollection` object relative to the number of seconds of the target period.

```{r timeActiveTracksCollection, eval = T, message = F, warning = F}
timeActiveTracksCollection <- function(timeframe, trcollection) {
  tstart = timeframe$tstart
  tend = timeframe$tend
  trcollection@tracksCollectionData$tactive = unlist(
    lapply(
      trcollection@tracksCollection,
      timeActiveTracks,
      tstart = tstart,
      tend = tend
    )
  )
  
  pctactive = trcollection@tracksCollectionData$tactive /
    as.integer(difftime(tend, tstart, units = "sec")) * 100
  
  return(pctactive)
}
```

## findGaps

Function in order to find gaps in a `Track` object based on the duration between measurements. The function takes the track and a tolrance or a threshold value as input. Additionally, the time period within gaps should be searched can be provided.

* Arguments:
    + `currenttrack`: A `Track` object.
    + `tstart`: a POSIXct object indicating the date and time of the start of the target period. Default is the first value of the `Track` object.
    + `tend`: a POSIXct object indicating the date and time of the end of the target period. Default is the last value of the `Track` object.
    + `threshold`: An integer value indicating the threshold for the time between two data points [s] above which this is considered as a gap in the `Track` object. Default is `threshold = 18000`, i.e. 5 hours. If `threshold = NULL`, the threshold value is calculated from the data as `mean(duration) + tolerance * sd(duration)`.
    + `tolerance`: An integer value indicating the tolerance of the threshold value calculated from the data if `threshold = NULL`. Default is `tolerance = 2`, i.e. 2 seconds.
    
* Value:
    + data.frame: A data.frame in the form of the connections slot of a `Track` object containing gaps between data points as entries.

```{r findGaps, eval = T, message = F, warning = F}
findGaps <- function(currenttrack, tstart = min(index(currenttrack@time)), tend = max(index(currenttrack@time)), threshold = 18000, tolerance = 2) {
    if (is.null(threshold) == TRUE) {
      
      gap_thresh <- 
        (mean(currenttrack@connections$duration) + tolerance * sd(currenttrack@connections$duration))
      
      connectionsub <-
        currenttrack@connections[index(currenttrack@time) >= tstart &
                                   index(currenttrack@time) <= tend,]
      na.omit(connectionsub[connectionsub$duration > gap_thresh,])
    }
    else{
      connectionsub <-
        currenttrack@connections[index(currenttrack@time) >= tstart &
                                   index(currenttrack@time) <= tend,]
      na.omit(connectionsub[connectionsub$duration > threshold,])
    }
    
  }
```

## countGaps

Function in order to count the number of gaps in a `Track` object using the function `findGaps`.

* Arguments:
    + `currenttrack`: A `Track` object.
    + `tstart`: a POSIXct object indicating the date and time of the start of the target period. Default is the first value of the `Track` object.
    + `tend`: a POSIXct object indicating the date and time of the end of the target period. Default is the last value of the `Track` object.
    + `threshold`: An integer value indicating the threshold for the time between two data points [s] above which this is considered as a gap in the `Track` object. Default is `threshold = 18000`, i.e. 5 hours. If `threshold = NULL`, the threshold value is calculated from the data as `mean(duration) + tolerance * sd(duration)`.
    + `tolerance`: An integer value indicating the tolerance of the threshold value calculated from the data if `threshold = NULL`. Default is `tolerance = 2`, i.e. 2 seconds.
    
* Value:
    + numeric: The number of gaps within the `Track` object.

```{r countGaps, eval = T, message = F, warning = F}
countGaps <- function(currenttrack, tstart = min(index(currenttrack@time)) , tend = max(index(currenttrack@time)), threshold = 18000, tolerance = 2) {
  length(
    findGaps(
      currenttrack, tstart = tstart, tend = tend, threshold = threshold, tolerance = tolerance
    )[,1]
  )
}
```

## gapDuration

Function in order to calculate the total duration of gaps [s] in a `Track` object using the function `findGaps`.

* Arguments:
    + `currenttrack`: A `Track` object.
    + `tstart`: a POSIXct object indicating the date and time of the start of the target period. Default is the first value of the `Track` object.
    + `tend`: a POSIXct object indicating the date and time of the end of the target period. Default is the last value of the `Track` object.
    + `threshold`: An integer value indicating the threshold for the time between two data points [s] above which this is considered as a gap in the `Track` object. Default is `threshold = 18000`, i.e. 5 hours. If `threshold = NULL`, the threshold value is calculated from the data as `mean(duration) + tolerance * sd(duration)`.
    + `tolerance`: An integer value indicating the tolerance of the threshold value calculated from the data if `threshold = NULL`. Default is `tolerance = 2`, i.e. 2 seconds.
    
* Value:
    + numeric: The sum of the duration of gaps within the `Track` object [s].

```{r gapDuration, eval = T, message = F, warning = F}
gapDuration <- function(currenttrack, tstart = min(index(currenttrack@time)) , tend = max(index(currenttrack@time)), threshold = 18000, tolerance = 2) {
  gaps <-
    findGaps(
      currenttrack, tstart = tstart, tend = tend, threshold = threshold, tolerance = tolerance
    )
  sum(gaps$duration)
}
```

## gapProportion

Function in order to calculate the proportion of the duration of gaps in a `Track` object relative to the duration of the total `Track` object (and within a specified time period) using the function `gapDuration`.

* Arguments:
    + `currenttrack`: A `Track` object.
    + `tstart`: a POSIXct object indicating the date and time of the start of the target period. Default is the first value of the `Track` object.
    + `tend`: a POSIXct object indicating the date and time of the end of the target period. Default is the last value of the `Track` object.
    + `threshold`: An integer value indicating the threshold for the time between two data points [s] above which this is considered as a gap in the `Track` object. Default is `threshold = 18000`, i.e. 5 hours. If `threshold = NULL`, the threshold value is calculated from the data as `mean(duration) + tolerance * sd(duration)`.
    + `tolerance`: An integer value indicating the tolerance of the threshold value calculated from the data if `threshold = NULL`. Default is `tolerance = 2`, i.e. 2 seconds.
    
* Value:
    + numeric: The proportion of the duration of gaps in a `Track` object relative to the duration of the total `Track` object (or a specified time period).

```{r gapProportion, eval = T, message = F, warning = F}
gapProportion <- function(currenttrack, tstart = min(index(currenttrack@time)) , tend = max(index(currenttrack@time)), threshold = 18000, tolerance = 2) {
  gapDuration(
    currenttrack,tstart = tstart, tend = tend, threshold = threshold, tolerance = tolerance
  ) / timeActiveTrack(currenttrack, tstart = tstart, tend = tend)
  
}
```

## totalGapDuration

Function in order to calculate the total duration of gaps [s] for all `Track` objects within a specified `Tracks` object (and for a specified time period).

* Arguments:
    + `currenttracks`: A `Tracks` object.
    + `tstart`: a POSIXct object indicating the date and time of the start of the target period. Default is the first value of the `Track` object.
    + `tend`: a POSIXct object indicating the date and time of the end of the target period. Default is the last value of the `Track` object.
    + `threshold`: An integer value indicating the threshold for the time between two data points [s] above which this is considered as a gap in the `Track` object. Default is `threshold = 18000`, i.e. 5 hours. If `threshold = NULL`, the threshold value is calculated from the data as `mean(duration) + tolerance * sd(duration)`.
    + `tolerance`: An integer value indicating the tolerance of the threshold value calculated from the data if `threshold = NULL`. Default is `tolerance = 2`, i.e. 2 seconds.
    
* Value:
    + numeric: The sum of the duration of gaps for all `Track` objects within the specified `Tracks` object (and within the specified time period) [s].

```{r totalGapDuration, eval = T, message = F, warning = F}
totalGapDuration <- function(currenttracks, tstart = min(currenttracks@tracksData$tmin), tend = max(currenttracks@tracksData$tmax), threshold = 18000, tolerance = 2) {
  sum(unlist(
    lapply(
      currenttracks@tracks, gapDuration, tstart = tstart, tend = tend, threshold = threshold, tolerance = tolerance
    )
  ))
}
```

## totalGapProportion

Function in order to calculate the proportion of the duration of gaps for all `Track` objects within a specified `Tracks` object relative to the duration of all `Track` objects within the specified `Tracks` object (and within a specified time period) using the function `gapDuration`.

* Arguments:
    + `currenttracks`: A `Tracks` object.
    + `tstart`: a POSIXct object indicating the date and time of the start of the target period. Default is the first value of the `Track` object.
    + `tend`: a POSIXct object indicating the date and time of the end of the target period. Default is the last value of the `Track` object.
    + `threshold`: An integer value indicating the threshold for the time between two data points [s] above which this is considered as a gap in the `Track` object. Default is `threshold = 18000`, i.e. 5 hours. If `threshold = NULL`, the threshold value is calculated from the data as `mean(duration) + tolerance * sd(duration)`.
    + `tolerance`: An integer value indicating the tolerance of the threshold value calculated from the data if `threshold = NULL`. Default is `tolerance = 2`, i.e. 2 seconds.
    
* Value:
    + numeric: The proportion of the duration of gaps for all `Track` objects within a specified `Tracks` object relative to the duration of all `Track` objects within the specified `Tracks` object (and within a specified time period).

```{r totalGapProportion, eval = T, message = F, warning = F}
totalGapProportion <- function(currenttracks, tstart = min(currenttracks@tracksData$tmin), tend = max(currenttracks@tracksData$tmax), threshold = 18000, tolerance = 2) {
  totalGapDuration(
    currenttracks, tstart = tstart, tend = tend, threshold = threshold, tolerance = tolerance
  ) / timeActiveTracks(currenttracks, tstart = tstart, tend = tend)
  
}
```

## findOutliersTrack

Function in order to identify connections between data points of a specified `Track` object with a speed above a specified threshold value.

* Arguments:
    + `currenttrack`: A `Track` object.
    + `tstart`: a POSIXct object indicating the date and time of the start of the target period. Default is the first value of the `Track` object.
    + `tend`: a POSIXct object indicating the date and time of the end of the target period. Default is the last value of the `Track` object.
    + `threshold`: An integer value indicating the threshold for the speed between two data points [m/s] above which this (connection) is considered as a measurement error. Default is `threshold = 180`.
    
* Value:
     + data.frame: A data.frame in the form of the connections slot of a `Track` object containing connections with speed values above `threshold`.

```{r findOutliersTrack, eval = T, message = F, warning = F}
findOutliersTrack <- function(currenttrack, tstart = min(index(currenttrack@time)), tend = max(index(currenttrack@time)), threshold = 180) {
  
  connectionsub <-
    currenttrack@connections[index(currenttrack@time) >= tstart &
                               index(currenttrack@time) <= tend, ]
  na.omit(connectionsub[connectionsub$speed > threshold, ])
}
```

## downByDrop

Function in order to subset a `Track` object by specifying a regular time interval between data points (i.e. performing downsampling). The first value of the `Track` object represents the starting point of the time point specification according to the target time interval. The last entry of a sequence of positioning measurements of the GPS tracker (in "spy" mode) is retained assuming that the assessed position data is the most accurate within the corresponding sequence. Points of a the `Track` object are only returned if there are at least two data values with a time interval as long as the specified time interval in the `Track` object.

* Arguments:
    + `currenttrack`: A `Track` object.
    + `timeInterval`: An integer value indicating a time interval [s] as target duration between data points of the `Track` object. Default is `timeInterval = 1770` (i.e. 29.5 minutes).
    
* Value:
     + the downsampled `Track` object.

```{r downByDrop, eval = T, message = F, warning = F}
downByDrop <- function(currenttrack, timeInterval = 1770) {
  j = length(currenttrack@time)
  dropindexes <- integer()
  # go through all fixes starting with the one before the last one and check the time interval to the following fix
  # in the track
  for (i in (length(currenttrack@time)-1):1) {
    if (difftime(currenttrack@time[j], currenttrack@time[i], units = "secs") < timeInterval) {
      dropindexes <- c(dropindexes, i) #if interval is below timeInterval (1770 secs), current fix will be dropped, "j" remains the following fix in the track
    }
    else{
      j <- i # else: current fix will not be dropped, but set as the new following fix "j" 
    }
  }
  
  # build new Track from data at all indexes not in 'dropindexes'
  # but only if there are at least two of them
  if(length(dropindexes) < length(currenttrack@time) - 1){
    downsampled <-
      Track(
        STIDF(
          sp = currenttrack@sp[-dropindexes],
          time = currenttrack@time[-dropindexes],
          endTime = currenttrack@endTime[-dropindexes],
          data = currenttrack@data[-dropindexes, ]
        )
      )
    return(downsampled)
  }
}
```

## downByDropTrs

Function in order to subset all `Track` objects within a specified `Tracks` object by specifying a regular time interval between data points (i.e. performing downsampling) and by using the function `downByDrop`.

* Arguments:
    + `currenttrs`: A `Tracks` object.
    + `timeInterval`: An integer value indicating a time interval [s] as target duration between data points of the `Track` object. Default is `timeInterval = 1770` (i.e. 29.5 minutes).
    
* Value:
     + the downsampled `Tracks` object.

```{r downByDropTrs, eval = T, message = F, warning = F}
downByDropTrs <- function(currenttrs, timeInterval = 1770){
  tracklist <- lapply(currenttrs@tracks, function(x) downByDrop(x))
  tracklist <- tracklist[!sapply(tracklist, is.null)]  
  if(length(tracklist) > 0){
    trsgen <- Tracks(tracklist)
    return(trsgen)
  }
}
```

## downByDrop

Function in order to subset a `Track` object by specifying a regular time interval between data points (i.e. performing downsampling). The first value of the `Track` object represents the starting point of the time point specification according to the target time interval. The last entry of a sequence of positioning measurements of the GPS tracker (in "spy" mode) is retained assuming that the assessed position data is the most accurate within the corresponding sequence. Points of a the `Track` object are only returned if there are at least two data values with a time interval as long as the specified time interval in the `Track` object.

* Arguments:
    + `currenttrack`: A `Track` object.
    + `timeInterval`: An integer value indicating a time interval [s] as target duration between data points of the `Track` object. Default is `timeInterval = 1770` (i.e. 29.5 minutes).
    + `quiet`: A logical value indicating if a warning should be printed if the specified `Track` object is shorter than the specified time interval. If `quiet = F`, a warning will be printed, if `quiet = T`, this will not happen.
    
* Value:
     + the downsampled `Track` object. If the specified `Track` object is shorter than the specified time interval, the function returns `NULL`.

```{r downByDrop2, eval = T, message = F, warning = F}
downByDrop <- function(currenttrack, timeInterval = 1770, quiet = F) {
  
  j = length(currenttrack@time)
  dropindexes <- integer()

  # go through all fixes starting with the one before the last one and check the time interval to the following fix in the track
  for (i in (length(currenttrack@time)-1):1) {
    if (difftime(currenttrack@time[j], currenttrack@time[i], units = "secs") < timeInterval) {
      dropindexes <- c(dropindexes, i) #if interval is below timeInterval (1770 secs), current fix will be dropped, "j" remains the following fix in the track
    }
    else{
      j <- i # else: current fix will not be dropped, but set as the new following fix "j" 
    }
  }
  
  # build new Track from data at all indexes not in 'dropindexes'
  # but only if there are at least two of them
  if(length(dropindexes) < length(currenttrack@time) - 1){
    downsampled <-
      Track(
        STIDF(
          sp = currenttrack@sp[-dropindexes],
          time = currenttrack@time[-dropindexes],
          endTime = currenttrack@endTime[-dropindexes],
          data = currenttrack@data[-dropindexes, ]
        )
      )
    return(downsampled)
  }else if (quiet == F){
    warning("Warning: The specified Track object is shorter than the specified time interval. No ouput created. \n")
    return(NULL)
  }
}
```

## downByDropTrs

Function in order to subset all `Track` objects within a specified `Tracks` object by specifying a regular time interval between data points (i.e. performing downsampling) and by using the function `downByDrop`.

* Arguments:
    + `currenttrs`: A `Tracks` object.
    + `timeInterval`: An integer value indicating a time interval [s] as target duration between data points of the `Track` object. Default is `timeInterval = 1770` (i.e. 29.5 minutes).
    + `quiet`: A logical value indicating if a warning should be printed if the specified `Track` object is shorter than the specified time interval. If `quiet = F`, a warning will be printed, if `quiet = T`, this will not happen.
    
* Value:
     + A list containing (1) the downsampled `Tracks` object (omitting `Track` objects that are shorter than the specified time interval) and a vector indicating the indices of the `Track` objects of the input `Tracks` object that are shorter than the specified time interval.

```{r downByDropTrs2, eval = T, message = F, warning = F}
downByDropTrs <- function(currenttrs, timeInterval = 1770, quiet = F){
  tracklist <- lapply(currenttrs@tracks, function(x) downByDrop(x, timeInterval = timeInterval))
  tooshort <- which(sapply(tracklist, is.null) == T)
  tracklist <- tracklist[!sapply(tracklist, is.null)]  
  if(length(tracklist) > 0){
    trsgen <- Tracks(tracklist)
    return(list(trsgen, tooshort))
  }else if(quiet == F){
    warning("Waring: All Track objects of the specified Tracks objects are shorter than the specified time interval.")
  }
}
```

## getNightTrack

Function in order to get all data points of a `Track` object within a specified time interval (several hours) for each day.

* Arguments:
    + `currenttrack`: A `Track` object.
    + `tstart`: A numeric value indicating the start of the time interval [h, values between 0 and 24]. The default is `tstart = 16`.
    + `tend`: A numeric value indicating the start of the time interval [h, values between 0 and 24]. `tend` has to be larger than `tstart`. The default is `tend = 20`. 
    
* Value:
     + the downsampled `Track` object (containing only data points within the specified time interval).
     
```{r getNightTrack, eval = T, message = F, warning = F}
getNightTrack <- function(currenttrack, tstart = 16, tend = 20) {
  #get Indexes of fixes within time frame
  nightindexes <-
    which(hour(currenttrack@time) >= tstart &
            hour(currenttrack@time) < tend)
  
  #build new Track from data at all indexes in 'nightindexes'
  #but only if there are at least two of them
  if(length(nightindexes)>1){
    nighttrack <-
      Track(
        STIDF(
          sp = currenttrack@sp[nightindexes],
          time = currenttrack@time[nightindexes],
          endTime = currenttrack@endTime[nightindexes],
          data = currenttrack@data[nightindexes, ]
        )
      )
    return(nighttrack)
  }
}
```

## getNightTrs
Function to apply getNightTrack on all Tracks of a Tracks-Object.

* Arguments:
    + `currenttrs`: A `Tracks` object.
    + `tstart`: A numeric value indicating the start of the time interval [h, values between 0 and 24]. The default is `tstart = 16`.
    + `tend`: A numeric value indicating the start of the time interval [h, values between 0 and 24]. `tend` has to be larger than `tstart`. The default is `tend = 20`. 
    
* Value:
     + the downsampled `Tracks` object (containing only data points within the specified time interval)

```{r getNightTrs, eval = T, message = F, warning = F}
getNightTrs <- function(currenttrs, tstart = 16, tend =20 ){
  tracklist <- lapply(currenttrs@tracks, getNightTrack, tstart=tstart, tend =tend)
  tracklist <- tracklist[!sapply(tracklist, is.null)]  
  if(length(tracklist) > 0){
    trsnight <- Tracks(tracklist)
    return(trsnight)
  }
}
```


## daynightFixesTrack

Function in order to get all data points of a `Track` object within a specified time interval (several hours) for each day (intended to separate data points sampled during night and day) as a `SpatialPointsDataFrame`.

* Arguments:
    + `currenttrack`: A `Track` object.
    + `tstart`: A numeric value indicating the start of the time interval [h, values between 0 and 24] 
    + `tend`: A numeric value indicating the start of the time interval [h, values between 0 and 24]. `tend` has to be larger than `tstart`.
    
* Value:
     + a `SpatialPointsDataFrame` containing all data of the slot `data` of the input `Track` object and a column `night` indicating if a data point is within the specified time interval (`night == 1`) or not (`night == 0`).
     
```{r daynightFixesTrack, eval = T, message = F, warning = F}
daynightFixesTrack <- function (currenttrack,
                                tstart = 16,
                                tend = 20) {
  
  #get indexes of fixes within time frame
  nightindexes <- which(hour(currenttrack@time) >= tstart & hour(currenttrack@time) < tend)
  
  # get SpatialPoints of all fixes during night
  nightfixes <- currenttrack@sp[nightindexes,]
  nightfixes <-
    SpatialPointsDataFrame(nightfixes, cbind(currenttrack@data[nightindexes,], data.frame(night = rep(
      1, length(nightfixes)
    ))))
  
  # get SpatialPoints of all other fixes
  if (length(nightfixes) > 0) {
    dayfixes <- currenttrack@sp[-nightindexes,]
    dayfixes <-
      SpatialPointsDataFrame(dayfixes, cbind(currenttrack@data[-nightindexes,], data.frame(night = rep(
        0, length(dayfixes))))
        )
  }else{
    dayfixes <- currenttrack@sp
    dayfixes <-
      SpatialPointsDataFrame(dayfixes, cbind(currenttrack@data, data.frame(night = rep(
        0, length(dayfixes))))
        )
  }
  
  if (length(nightfixes) == 0) {
    return(dayfixes)
  } else if (length(dayfixes) == 0) {
    return(nightfixes)
  } else{
    allfixes <- rbind(dayfixes, nightfixes)
    return(allfixes)
  }
  
}

# alternative (same results, but not ordered according to night)
daynightFixesTrack <- function (currenttrack,
                                tstart = 16,
                                tend = 20) {
  
  #get indexes of fixes within time frame
  nightindexes <- which(hour(currenttrack@time) >= tstart & hour(currenttrack@time) < tend)
  
  # create SpatialPointsDataFrame with new attribute night
  fixes.sp <- currenttrack@sp
  fixes.data <- currenttrack@data
  night <- rep(0, nrow(fixes.data))
  night[nightindexes] <- 1
  fixes.data$night <- night
  fixes <- SpatialPointsDataFrame(fixes.sp, fixes.data)
  
  # return fixes
  return(fixes)
  
}
```

## daynightFixesTracks

Function in order to get the data points of all `Track` objects in a `Tracks` object within a specified time interval (several hours) for each day (intended to separate data points sampled during night and day) as a `SpatialPointsDataFrame` using the function `daynightFixesTrack`.

* Arguments:
    + `currenttracks`: A `Tracks` object.
    + `tstart`: A numeric value indicating the start of the time interval [h, values between 0 and 24] 
    + `tend`: A numeric value indicating the start of the time interval [h, values between 0 and 24]. `tend` has to be larger than `tstart`.
    
* Value:
     + a `SpatialPointsDataFrame` containing all data of the slot `data` of all `Track` objects in the input `Tracks` object and a column `night` indicating if a data point is within the specified time interval (`night == 1`) or not (`night == 0`).
     
```{r daynightFixesTracks, eval = T, message = F, warning = F}
daynightFixesTracks <- function(currenttracks,
                                tstart = 16,
                                tend = 20) {
  trs_daynightfixes <-
    do.call(
      rbind,
      lapply(
        currenttracks@tracks,
        daynightFixesTrack,
        tstart = tstart,
        tend = tend
      )
    )
  return(trs_daynightfixes)
}
```

## getNightConnectionsTrack

Function in order to get all data points of the slot `connections` of a `Track` object within a specified time interval (several hours) for each day (intended to separate data points sampled during night and day) as a data frame.

* Arguments:
    + `currenttrack`: A `Track` object.
    + `tstart`: A numeric value indicating the start of the time interval [h, values between 0 and 24] 
    + `tend`: A numeric value indicating the start of the time interval [h, values between 0 and 24]. `tend` has to be larger than `tstart`.
    
* Value:
     + a data frame representing the corresponding data points of the slot `connections` of the `Track` object within the time interval. 
     
```{r getNightConnectionsTrack, eval = T, message = F, warning = F}
getNightConnectionsTrack <- function(currenttrack,
                                tstart = 16,
                                tend = 20) {
  
  # get indexes of fixes within time frame  
  nightindexes <- which(hour(currenttrack@time) >= tstart & hour(currenttrack@time) < tend)
  
  # get connection having the nightly fixes as start
  nightconnections <- currenttrack@connections[nightindexes,]
  
  # extract only those connection having also a nightly fix as end (index +1)
  nightconnections <-
    nightconnections[is.element(strtoi(row.names(nightconnections)) + 1, nightindexes),]
  return(nightconnections)
}
```

## getNightMovementTracks

Function in order to get the mean value for the column `distance` of the slot `connections` of all `Track` objects of a `Tracks` object within a specified time interval (several hours) for each day (intended to separate data points sampled during night and day) using the function `getNightConnectionsTrack`. Additionally, the function removes all data points with a value `connections$duration < 1700` and`connections$duration > 1900` (s).

* Arguments:
    + `currenttracks`: A `Tracks` object.
    + `tstart`: A numeric value indicating the start of the time interval [h, values between 0 and 24] 
    + `tend`: A numeric value indicating the start of the time interval [h, values between 0 and 24]. `tend` has to be larger than `tstart`.
    
* Value:
     + a numeric value representing the mean of the column `speed` of the slot `connections` of all `Track` objects of a `Tracks` object within the time interval and with a value `connections$duration > 1700` and`connections$duration < 1900` (s). 
     
```{r getNightMovementTracks, eval = T, message = F, warning = F}
getNightMovementTracks <- function(currenttracks, 
                                   tstart = 16, 
                                   tend = 20){
  
  # get connections
  trs_nightconnections <- 
    do.call(
      rbind,
      lapply(
        currenttracks@tracks,
        getNightConnectionsTrack, 
        tstart = tstart, 
        tend = tend
        )
      )
  
  # eliminate data points outside duration target interval
  trs_nightconnections <- trs_nightconnections[trs_nightconnections$duration > 1700 & trs_nightconnections$duration < 1900,]
  
  # get mean of corresponding distance values
  return(mean(trs_nightconnections$distance))
}
```

## getNightSpeedTracks

Function in order to get the mean value for the column `speed` of the slot `connections` of all `Track` objects of a `Tracks` object within a specified time interval (several hours) for each day (intended to separate data points sampled during night and day) using the function `getNightConnectionsTrack`.

* Arguments:
    + `currenttracks`: A `Tracks` object.
    + `tstart`: A numeric value indicating the start of the time interval [h, values between 0 and 24] 
    + `tend`: A numeric value indicating the start of the time interval [h, values between 0 and 24]. `tend` has to be larger than `tstart`.
    
* Value:
     + a numeric value representing the mean of the column `speed` of the slot `connections` of all `Track` objects of a `Tracks` object within the time interval. 
     
```{r getNightSpeedTracks, eval = T, message = F, warning = F}
#same as above but without subsetting of durations and calculating speed
getNightSpeedTracks <- function(currenttracks, 
                                tstart = 16, 
                                tend = 20){
  
  trs_nightconnections <- 
    do.call(
      rbind,
      lapply(
        currenttracks@tracks,
        getNightConnectionsTrack, 
        tstart = tstart, 
        tend = tend
        )
      )
  
  # get mean of corresponding speed values
  return(mean(trs_nightconnections$speed))
}
```

## getDayConnectionsTrack

Function in order to get all data points of the slot `connections` of a `Track` object outside a specified time interval (several hours) for each day (intended to separate data points sampled during night and day) as a data frame (complementary to `getNightConnectionsTrack`).

* Arguments:
    + `currenttrack`: A `Track` object.
    + `tstart`: A numeric value indicating the start of the time interval [h, values between 0 and 24] 
    + `tend`: A numeric value indicating the start of the time interval [h, values between 0 and 24]. `tend` has to be larger than `tstart`.
    
* Value:
     + a data frame representing the corresponding data points of the slot `connections` of the `Track` object outside the time interval. 
     
```{r getDayConnectionsTrack, eval = T, message = F, warning = F}
getDayConnectionsTrack <- function(currenttrack,
                              tstart = 16,
                              tend = 20) {
  
  # get connection having the nightly fixes as start
  nightconnections <-
    getNightConnectionsTrack(currenttrack, tstart, tend)
  
  # get the corresponding daily fixes
  dayconnections <-
    currenttrack@connections[-strtoi(row.names(nightconnections)), ]
  
  return(dayconnections)
}
```

## getDayMovementTracks

Function in order to get the mean value for the column `distance` of the slot `connections` of all `Track` objects of a `Tracks` object outside a specified time interval (several hours) for each day (intended to separate data points sampled during night and day) using the function `getDayConnectionsTrack`. Additionally, the function removes all data points with a value `connections$duration < 1700` and`connections$duration > 1900` (s).

* Arguments:
    + `currenttracks`: A `Tracks` object.
    + `tstart`: A numeric value indicating the start of the time interval [h, values between 0 and 24] 
    + `tend`: A numeric value indicating the start of the time interval [h, values between 0 and 24]. `tend` has to be larger than `tstart`.
    
* Value:
     + a numeric value representing the mean of the column `distance` of the slot `connections` of all `Track` objects of a `Tracks` object outside the time interval and with a value `connections$duration > 1700` and`connections$duration < 1900` (s). 
     
```{r getDayMovementTracks, eval = T, message = F, warning = F}
#function to apply getDayConnectionsTrack on all tracks of a Tracks-Object, remove connections < 1700 and >1900 secs
#duration and return mean distance of alle remaining connections
getDayMovementTracks <- function(currenttracks, 
                                 tstart = 16, 
                                 tend = 20){
  
  # get connections
  trs_dayconnections <- 
    do.call(rbind,
            lapply(
              currenttracks@tracks,
              getDayConnectionsTrack, 
              tstart = tstart, 
              tend = tend
              )
            )
  
  # eliminate data points outside duration target interval
  trs_dayconnections <- trs_dayconnections[trs_dayconnections$duration > 1700 & trs_dayconnections$duration < 1900,]
  
  # get mean of corresponding distance values
  return(mean(trs_dayconnections$distance))
}
```

## getDaySpeedTracks

Function in order to get the mean value for the column `speed` of the slot `connections` of all `Track` objects of a `Tracks` object outside a specified time interval (several hours) for each day (intended to separate data points sampled during night and day) using the function `getDayConnectionsTrack`.

* Arguments:
    + `currenttracks`: A `Tracks` object.
    + `tstart`: A numeric value indicating the start of the time interval [h, values between 0 and 24] 
    + `tend`: A numeric value indicating the start of the time interval [h, values between 0 and 24]. `tend` has to be larger than `tstart`.
    
* Value:
     + a numeric value representing the mean of the column `speed` of the slot `connections` of all `Track` objects of a `Tracks` object outside the time interval. 
     
```{r getDaySpeedTracks, eval = T, message = F, warning = F}
#same as above but without subsetting of durations and calculating speed
getDaySpeedTracks <- function(currenttracks, 
                                tstart = 16, 
                                tend = 20){
  
  trs_dayconnections <- 
    do.call(
      rbind,
      lapply(
        currenttracks@tracks,
        getDayConnectionsTrack, 
        tstart = tstart, 
        tend = tend
        )
      )
  
  # get mean of corresponding speed values
  return(mean(trs_dayconnections$speed))
}
```

## daytimeMovement

Function in order to compute several summary indices (mean distance, mean speed and maximum speed between subsequent points) for a `Track` object inside or outside a specified time interval (several hours) for each day using the function `getNightConnectionsTrack`.

* Arguments:
    + `currenttrack`: A `Track` object.
    + `nightstart`: A numeric value indicating the start of the time interval [h, values between 0 and 24] 
    + `nightend`: A numeric value indicating the start of the time interval [h, values between 0 and 24]. `nightend` has to be larger than `nightstart`.
    + `night`: A logical value indicating if the computations should be performed on the data points within the time interval (`night == T`) or outside the time interval (`night == F`). Default is `night = T`.
    
* Value:
     + a list containing as columns:
          1. `mean_distance`: The mean distance between subsequent data points of the `Track` object within or outside the specified time interval.
          2. `mean_speed`: The mean speed between subsequent data points of the `Track` object within or outside the specified time interval.
          3. `max_speed`: The maximum speed between subsequent data points of the `Track` object within or outside the specified time interval.
     
```{r daytimeMovement, eval = T, message = F, warning = F}
daytimeMovement <-
  function(currenttrack,
           nightstart,
           nightend,
           night = TRUE) {
    
    #call function to get nightly connections passing on the input parameters
    currentconnections <-
      getNightConnectionsTrack(currenttrack, nightstart, nightend)
    # invert selection, if night==FALSE
    if (night == FALSE) {
      currentconnections <-
        currenttrack@connections[-strtoi(row.names(currentconnections)),]
    }
    #create list with movement indicators during desired time of day
    movement <-
      list(
        mean_distance = mean(currentconnections$distance),
        mean_speed = mean(currentconnections$speed),
        max_speed = max(currentconnections$speed)
      )
    return(movement)
  }
```

## qTopology

Function to determine topology for grid and quadratcount, i.e. size in x and y such that the window of the ppp can be split in an even number of quadrats,approximating a certain target edge length, e.g. 1000m. This function is used by function `pointsPerQuad` to create the cells in which to count the number of points.

* Arguments:
    + `ppp`: A `ppp` (point pattern dataset) object.
    + `targetQsize`: Target size of the quadrats to be created.
    
* Value:
    + A list containing the size and number of cells in x and y

```{r qTopology, eval = T, message = F, warning = F}
qTopology <- function(ppp, targetQsize) {
  #determine next number of quadrats in x and y direction, by simple rounding
  targetQsize <- targetQsize
  nqx <- round((ppp$window$xrange[2] -
  ppp$window$xrange[1]) / targetQsize)
  nqy <- round((ppp$window$yrange[2] -
  ppp$window$yrange[1]) / targetQsize)
  #determine quadrat size using rounded number of cells
  qsizeX <-
  (ppp$window$xrange[2] - ppp$window$xrange[1]) / nqx
  qsizeY <-
  (ppp$window$yrange[2] - ppp$window$yrange[1]) / nqy
  
  return (list(
  qsizeX = qsizeX,
  qsizeY = qsizeY,
  nqx = nqx,
  nqy = nqy
  ))
}
```

## pointsPerQuad

Function to determine points per cell (of a given size) in a tracks-object. Takes a `Tracks` object and a target size of the cells as input and returns a `SpatialGridDataFrame` with quadrat cells and the number of points within them. This function is used by function `extractClusters` to count the number of points within cells before determining clusters of points.

* Arguments:
    + `trs`: A `Tracks`object.
    + `qsize`: Target size of the quadrats in which to count the number of points of the `Tracks` object.

* Value:
    + A `SpatialGridDataFrame` with quadrat cells and the number of points within them

```{r pointsPerQuad, eval = T, message = F, warning = F}
pointsPerQuad <- function(trs, qsize) {
  #transform to UTM
  trsSP <- as(as(trs, "SpatialLines"), "SpatialPoints")
  trsSPtrans <-
  spTransform(
    trsSP,
    CRS(
    "+proj=utm +zone=46 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
    )
  )
  #convert to ppp
  trsPPP <- as(trsSPtrans, "ppp")
  
  #use function qTopology to determine dimensions and number of cells for grid and quadratcount
  qtopo <- qTopology(trsPPP, qsize)
  qsizeX <- qtopo$qsizeX
  qsizeY <- qtopo$qsizeY
  nqx <- qtopo$nqx
  nqy <- qtopo$nqy
  
  #create SpatialGridDataFrame with number of counts of points per grid cell using quadratcount,   and with dimensions determined above
  trsGrid <-
  SpatialGridDataFrame(
    GridTopology(
      c(
        trsPPP$window$xrange[1] + qsizeX / 2,
        trsPPP$window$yrange[1] + qsizeY / 2
      ),
      c(qsizeX, qsizeY),
      c(nqx, nqy)
    ),
    data.frame(count = as.numeric(matrix(
    as.numeric(quadratcount(trsPPP, nx = nqx, ny = nqy)), nqx, nqy, byrow =
    T
    ))),
    proj4string = proj4string(trsSPtrans)
  )
  
  return (trsGrid)
}
```

## extractClusters

Function to extract clusters using the function `pointsPerQuad`. Takes a `Tracks` object, a cellsize (for the cells in which to count the points) and a threshold for the number of points per cell as arguments. Returns a `SpatialPolygonsDataFrame` holding the cells determined as clusters.

* Arguments:
    + `currenttracks`: A `Tracks`object.
    + `cellsize`: Desired size of the cells in which to count the points.
    + `threshold`: Threshold (number of points per cell) defining a "cluster".

* Value: 
    + A `SpatialPolygonsDataFrame` holding the cells determined as clusters

```{r extractClusters, eval = T, message = F, warning = F}
extractClusters <-
  function(currenttracks,
           cellsize = 1000,
           threshold = 300) {
    trsGrid <- pointsPerQuad(currenttracks, cellsize)
    #convert to SpatialPolygonsDataFrame
    trsGridSPDF <- as(trsGrid, "SpatialPolygonsDataFrame")
    #get cells with count > threshold
    clusters <- trsGridSPDF[which(trsGridSPDF$count > threshold), ]
    return(clusters)
  }
```

## searchNextVisit

Function that checks whether the clusters/campsites have been visited more than the currently known visits (`times_visited`). Updates `times_visited` and determines end (latest point in cell) of current visit. This function is used by function `clusterOrder()`.

* Arguments:
    + `cells`: A `SpatialPolygonsDataFrame` holding the cells determined as clusters/campsites
    + `trs_spdf`: A `SpatialPointsDataFrame` of the household movement (as converted from `Tracks` object)
    
* Value:
    + `cells`: A `SpatialPolygonsDataFrame` holding the clusters/campsites with updated `times_visited`

```{r searchNextVisit, eval = T, message = F, warning = F}
searchNextVisit <- function(cells, trs_spdf) {
  
  #get last occurence of points in cell from the cluster data frame
  last_in_cell <- cells$last_in_cluster 
  
  #get the start of current visit from the third last coloumn of data frame
  first_of_visit <- cells@data[[ncol(cells@data) - 2]] 
  
  #get currently determined latest point of current visit, i.e. the second last coloumn
  last_of_visit <- cells@data[[ncol(cells@data)-1]] 
  
  #get the current rank, i.e. the last coloumn
  current_rank <- cells@data[[ncol(cells@data)]] 
  
  #loop through clusters by rank
  for (i in 1:(max(current_rank, na.rm = T) - 1)) {
    
    # if current latest point is later in time than the earliest point of the following cluster...
    if (last_in_cell[which(current_rank == i)] > first_of_visit[which(current_rank == i +
                                                                           1)]) {
      
      #...the cluster has been visited again later, so set times_visited + 1
      cells$times_visited[which(current_rank == i)] <-
        cells$times_visited[which(current_rank == i)] + 1 
     
       # also determine end of current visit as the latest point in the cluster that is still earlier than the earliest point in the following cluster
      last_of_visit[which(current_rank == i)] <-
        max(na.omit(trs_spdf$time[trs_spdf$clrank == i &
                                   trs_spdf$time < first_of_visit[which(current_rank == i + 1)]])) 
      # set newVisit to TRUE
      cells$newVisit[which(current_rank == i)] <- TRUE
    }
    else{
      #set newVisit to FALSE
      cells$newVisit[which(current_rank == i)] <- FALSE
    }
  }
  
  #the cluster which is last in line of 1st visits, always has only one visit
  cells$newVisit[which(current_rank == max(current_rank, na.rm = T))] <- FALSE 
  
  #update end time of current visit (second last coloumn) with newly determined last last_of_visit
  cells@data[[ncol(cells@data)-1]] <- last_of_visit 
  
  
  return(cells)
}
```

## findStarts

Function determining the start date/time of the latest visit in a cluster/campsite if an additional visit has been detected by `searchNextVisit()`. `cells` should be object of clusters/campsites as returned by `searchNextVisit()`. This function is used by function `clusterOrder()`.

* Arguments:
    + `cells`: A `SpatialPolygonsDataFrame` holding the cells determined as clusters/campsites
    + `trs_spdf`: A `SpatialPointDataFrame` of the household movement (as converted from `Tracks` object)
    
* Value: 
    + `next_start`: A vector of `POSIXct` objects holding the starts (first points) of the additional visits.
    
```{r findStarts, eval = T, message = F, warning = F}
findStarts <- function(cells, trs_spdf) {
  #get the end of previous visit from the second last coloumn of data frame
  last_of_previous <- cells@data[[ncol(cells@data)-1]] 
  
  #create POSIXct vector for next start values (using visit1_start as dummy values)
  next_start <- cells$visit1_start 
  
  #get the current rank, i.e. the last coloumn
  current_rank <- cells@data[[ncol(cells@data)]] 
  
  #loop through clusters following rank
  for (i in 1:(max(current_rank, na.rm = T))) {
    
    # if new visit has been detected before:
    if (cells$newVisit[which(current_rank == i)]  == TRUE) {
      
      #determine next_start within cluster as the earliest point that is in that cluster and later than the end of the previous visit
      next_start[which(current_rank == i)] <- 
        min(na.omit(trs_spdf$time[trs_spdf$clrank == i &
                                   trs_spdf$time > last_of_previous[which(current_rank == i)]])) 
      
    } else {
      next_start[which(current_rank == i)] <- NA
    }
  } 
  
  return(next_start)
}
```

## clusterOrder

Function that identifies campsites (clusters of points) of a household (`Tracks` object) and for each cluster/campsite determines the number of visits, the order in which the clusters have been visited, and the start and end times (first and last point) of each visits. Uses function `extractClusters()` to detect the campsites. Also uses functions `searchNextVisit()` and `findStarts()` described above.

* Arguments:
    + `trs`: A `Tracks`object.
    + `cellsize`: Desired size of the cells in which to count the points when searching clusters/campsites. Passed on to function `extractClusters()`. 
    + `threshold`: Threshold (number of points per cell) defining a cluster. Passed on to function `extractClusters()`.
   
    
* Value: 
  + `clusters`: A `SpatialPolygonsDataFrame` holding the cells determined as clusters including data on the number of visits per cluster, start and end times etc.
  
```{r clusterOrder, eval = T, message = F, warning = F}
clusterOrder <- function(trs, cellsize = 800, threshold = 20) {
  
##prepare data by extracting clusters and transforming Tracks object to SPDF to allow overlaying with polygons of clusters:
  clusters <- extractClusters(trs, cellsize = cellsize, threshold = threshold)
  clusters$clid <- rownames(clusters@data) # save id of cell in dataframe as "clid"
  trs_spdf <- spTransform(as(trs, "SpatialPointsDataFrame"), CRSobj = clusters@proj4string)
  trs_spdf@data$clid <- over(trs_spdf, clusters)$clid #assign clid of corresponding cluster to each point
  
##begin ordering
  #detect and rank first visit of each cluster/campsite:
  
  #determine first visit for each cluster
  visit1_start <- aggregate(trs_spdf["time"], by = clusters, FUN = min)$time 
  
  # rank cluster regarding first visit
  visit1_rank <- rank(visit1_start) 
  
  #determine latest point of the track within each cluster
  clusters$last_in_cluster <- aggregate(trs_spdf["time"], by = clusters, FUN = max)$time  
  
  #temporarily set end of first visit to the last point in cluster (will be updated during ordering below)
  visit1_end <- clusters$last_in_cluster 
  
  clusters$times_visited <- 1
  
  # add start, end and rank of visit to dataframe of the clusters/campsites
  clusters@data <- cbind(clusters@data, visit1_start, visit1_end, visit1_rank) 
  remove(visit1_rank, visit1_start, visit1_end)
  
  # assign rank of cluster to corresponding points of trs_spdf
  trs_spdf@data$clrank <- over(trs_spdf, clusters)$visit1_rank 
  
  #create vector for holding information on whether a new visit has been detected
  newVisit <- rep(TRUE, length(clusters$visit1_rank)) 
  
  #attach information on new visits to the first coloumn in order to keep the last coloumn for the end of the corresponding visit
  clusters@data <- cbind(newVisit,clusters@data) 
  
  #find furhter visits:
  
  i = 2 #index for naming the coloumns
  
   #while there were at least two clusters with additional visits to be ordered in the previous iteration, continue. Otherwised ordering is finished
  while (length(which(clusters$newVisit == TRUE))>1) { 
    
    #in each cluster look for visits later than the currently known ones:
    clusters <- searchNextVisit(clusters, trs_spdf) 
    
      #if additional visits were found, find starts and ends of these visits, whereas ends are defined as latest points in each cluster (in the next iteration it will be checked,whether they belong to another visit of the same cluster)
      if (any(clusters$newVisit == TRUE)) { 
        clusters@data <-
        cbind(
          clusters@data,
          findStarts(clusters, trs_spdf),
          aggregate(trs_spdf["time"], by = clusters, FUN = max)$time
        )
      
      #set rows without additional visits to NA
      clusters@data[[ncol(clusters@data)]][is.na(clusters@data[[ncol(clusters@data)-1]])] <-NA 
      
      #rank clusters according to start of current visit and add rank to data frame
      rank <- rank(clusters@data[[ncol(clusters@data)]]) 
      rank[which(is.na(clusters@data[[ncol(clusters@data)]]))] <- NA
      clusters@data <- cbind(clusters@data, rank)
      
      #rename coloumns
      names(clusters@data)[ncol(clusters@data)] <- paste("visit",i,"_rank",sep="")
      names(clusters@data)[ncol(clusters@data)-1] <- paste("visit",i,"_end",sep="")
      names(clusters@data)[ncol(clusters@data)-2] <- paste("visit",i,"_start",sep="")
      i <- i+1
      }
  }
  
  print("Finished")
  plot(trs_spdf@data$time, trs_spdf@data$clrank, type = "l")
  return(clusters)
}

```

## elevDiff

## abselevDiff

## exDataTracks

Function in order to extract the slot `data` for all `Track` objects of a `Tracks object` and to add the slot `time` for all `Track` objects of a `Tracks object` as a column to the resulting `data.frame` object.

* Arguments:
    + `trs`: A `Tracks`object.

* Value: 
    + `list` containing the `data.frame` objects representing the slot `data` and `time` (binded together as `data.frame`) of the `Track` objects of the specified `Tracks` object as elements.

```{r exDataTracks, eval = T, message = F, warning = F}
exDataTracks <- function(trs
                      ){
  
  require(lubridate)
  require(spacetime)
  
  df <- lapply(trs@tracks, function(x){
    df <- x@data
    df$time <- as.POSIXct(x@time)
    df
    })
  
  df1 <- df[[1]]
  for(i in c(2:length(df))){
    df1 <- merge(df1, df[[i]], all = T)
  }
  
  df1 <- df1[order(df1$time),]
  
  return(df1)
}
```

## locationsTracks

Function in order to identify distinct locations in a `Tracks` object and the order of the visit of these locations and in order to compute various variables concerning the visit of a specific location (mean latitude, mean longitude, mean elevation, residence time, arrival time, departure time, speed). The identification of locations is based on the identification of clusters of fixes by identifying intersecting buffers around each fix. Campsites are distinguished from other locations by a specified minimal residence time.

* Arguments:
    + `trs`: A `Tracks`object.
    + `radius`: The radius of the buffers computed around each value [m] which are used for clustering values to locations. Default is `radius = 200` [m].
    + `t.min`: The minimum residence time at a specific location [s] which is used to classify locations as campsites (if the residence time is larger than `t.min`) in contrast to other locations. The default is `t.min = 345600`, i.e. 4 days.

* Value: 
    + A `Tracks` object containing the following columns within the data slot:
        1. `location`: An integer value discriminating different locations.
        2. `res.time`: The residence time at a specific location [s].
        3. `campsite`: A logical value indicating whether a specific visit of a location is considered as campsite or not (based on `t.min`).
        4. `arrival.time`: A character representing the arrival time for a specific visit of a location. The format is `"%Y-%m-%d %H:%M:%S"`.
        5. `departure.time`: A character representing the departure time for a specific visit of a location. The format is `"%Y-%m-%d %H:%M:%S"`.
        6. `lat`: A numeric value representing the centroids for the latitude of fixes corresponding to a specific visit of a location [].
        7. `lon`: A numeric value representing the centroids for the longitude of fixes corresponding to a specific visit of a location [].
        8. `alt`: A numeric value representing the mean elevation value of fixes corresponding to a specific visit of a location [m].
        9. `speed`: A numeric value indicating the mean speed at the time fixes were taken for fixes corresponding to a specific visit of a location [m s<sup>-1</sup>].


```{r locationsTracks, eval = T, message = F, warning = F}
locationsTracks <- function(trs,
                            radius = 200,
                            t.min = 345600
){
  
  # get Tracks data
  trs.df <- exDataTracks(trs)
  
  # convert track to SpatialPointsDataFrame and transform to UTM
  trsSP <- as(as(trs, "SpatialLines"), "SpatialPoints")
  trsSP <-
    spTransform(
      trsSP,
      CRS(
        "+proj=utm +zone=46 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
      )
    )
  trsSP <- SpatialPointsDataFrame(trsSP, trs.df, match.ID = F)
  
  # indices with points that have not been assigned to a cluster yet
  leftover <- c(1:length(trsSP))
  leftover.old <- leftover
  first <- T
  
  while(length(leftover) != 0){
    
    # subset points for buffering (1%)
    # ind.select <- leftover[seq(1, length(leftover), by = length(leftover)*0.01)]
    ind.select <- leftover[sample(c(1:length(leftover)), size = ceiling(length(leftover)*0.01))]
    
    # compute buffer
    buffer.trs <- gBuffer(trsSP[ind.select,], width = radius, quadsegs = 25)
    
    # get intersecting points
    a.new <- over(trsSP, disaggregate(buffer.trs))
    
    if(first == T){
      # get intersecting points
      buffer.trs.tot <- buffer.trs
      a.tot <- a.new
      
      first = F
    }
    
    # define points that were inside a buffer at any loop run
    a.tot[which(is.na(a.tot))] <- a.new[which(is.na(a.tot))]
    
    # define total buffer range
    buffer.trs.tot <- gUnion(buffer.trs, buffer.trs.tot)
    
    # subset leftover
    if(length(which(is.na(a.tot))) != 0){
      leftover <- leftover.old[which(is.na(a.tot))]
    }else{
      leftover = NULL
      
      a.tot <- over(trsSP, disaggregate(buffer.trs.tot))
    }
    
  }
  
  # add variable to trsSP
  trsSP$campsites <- a.tot
  
  if(length(unique(a.tot)) == 1){
    warning("Only one location identified!")
    return(NULL)
  }
  
  # find order of campsite visits
  order.campsite.vis <- 1
  for(fi in c(1:length(a.tot))){
    if(a.tot[fi] != a.tot[order.campsite.vis[length(order.campsite.vis)]]){
      order.campsite.vis <- c(order.campsite.vis, fi)
    }
    if(fi == length(a.tot) && order.campsite.vis[length(order.campsite.vis)] != fi){
      order.campsite.vis <- c(order.campsite.vis, fi)
    }
  }
  
  # create a list with respective indices
  order.campsite.vis <- rbind(order.campsite.vis[-length(order.campsite.vis)], order.campsite.vis[-1])
  order.campsite.vis <- list(apply(order.campsite.vis, 2, function(x){x[1]:(x[2]-1)}))[[1]]
  
  # calculate various variables connected to campsites
  campsites.var <- data.frame(location = trsSP$campsites[sapply(order.campsite.vis, function(x){x[1]})],
                              res.time = sapply(order.campsite.vis, function(x){difftime(trsSP$time[range(x)[2]], trsSP$time[range(x)[1]], units = "sec")}))
  
  # define a variable classifying locations as campsites or short term visits
  campsites.var$campsite <- rep(T, nrow(campsites.var))
  campsites.var$campsite[which(campsites.var$res.time < t.min)] <- F
  
  # get arrival and departure time
  campsites.var$arrival.time <- sapply(order.campsite.vis, function(x){as.character(trsSP$time[x[1]])})
  campsites.var$departure.time <- sapply(order.campsite.vis, function(x){as.character(trsSP$time[x[length(x)]])})
  
  # get mean position data for each location visit
  centr.coords <- data.frame()
  for(visit_i in c(1:length(order.campsite.vis))){
    
    centr.coords <- rbind(centr.coords, apply(matrix(trsSP@coords[order.campsite.vis[[visit_i]],], ncol = 2), 2 , mean))
    
  }
  centr.coords$alt <- sapply(order.campsite.vis, function(x){mean(trsSP$HEIGHT[x])})
  names(centr.coords) <- c("lon", "lat", "alt")
  
  # convert to SP
  centr.coords <- SpatialPoints(centr.coords[,-3], proj4string = CRS(proj4string(trsSP)))
  
  # transform back to WGS84 longitude latitude
  a <- spTransform(centr.coords, trs@tracks[[1]]@sp@proj4string)
  
  # add variables to campsites.var
  campsites.var$lon <- a@coords[,1]
  campsites.var$lat <- a@coords[,2]
  campsites.var$alt <- sapply(order.campsite.vis, function(x){mean(trsSP$HEIGHT[x])})
  
  # get mean speed at each location visit
  campsites.var$speed <- sapply(order.campsite.vis, function(x){mean(trsSP$SPEED[x])})
  
  # reorder indices of locations (according to arrival time)
  done <- NULL
  iter <- 1
  location.new <- rep(0, nrow(campsites.var))
  for(i in c(1:nrow(campsites.var))){
    if(i %in% done){
      next()
    }else{
      done <- c(done, which(campsites.var$location == campsites.var$location[i]))
    location.new[which(campsites.var$location == campsites.var$location[i])] <- iter
    iter <- iter+1
    }
  }
  campsites.var$location <- location.new
  
  # create SpatialPointsDataFrame from campsites.var
  campsites.var1 <- campsites.var
  campsites.var <- SpatialPoints(coords = data.frame(lon = campsites.var$lon, lat = campsites.var$lat), proj4string = CRS(
    "+proj=longlat +zone=46 +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"
  ))
  campsites.var <-
    spTransform(
      campsites.var,
      CRS(
        "+proj=utm +zone=46 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
      )
    )
  

  
  # create Track object from campsites.var
  campsites.var <- Track(STIDF(sp = campsites.var, time = as.POSIXct(campsites.var1$arrival.time) , data = campsites.var1, endTime = as.POSIXct(campsites.var1$departure.time)))
  
  return(campsites.var)
}
```

## summaryIndicators1

Function in order to compute various summary indicators for the movement of herders, solely based on a `Tracks` object. The function uses the output of the function `locationsTracks` (i.e. is based on a `Tracks` object). Therefore, movement summary indicators are solely based on identified locations, i.e. distances represent the linear distances between the locations.  

* Arguments:
    + `trsloc`: A `Tracks`object as returned by `locationsTracks`.
    + `time`: A `POSIXct` vector of length two specifying a target time interval for which to compute the summary indicators. `time[1]` represents the start time point, `time[2]` represents the start time point. All locations with `loctrs$arrival.time >= time[1]` and `loctrs$departure.time <= time[2]` will be considered. If `time = NULL`, no temporal subsetting of the data is performed. Default is `time = NULL`.
    + `only.campsites`: A logical value indicating if during the computation of the summary indicators only campsites (`only.campsites = T`) or all identified locations (`only.campsites = F`) should be considered. Default is `only.campsites = T`.

* Value: 
    + `data.frame` containing the following columns:
        1. 
     
* Issues:
    + The function will be extended for the use with outputs from `extractClusters`.


```{r summaryIndicators1, eval = T, message = F, warning = F}
summaryIndicators1 <- function(){}
```

## FixesForDays

Function in order to identify the days within a specified time period, for which data points are available within a specified `Tracks` object.

* Arguments:
    + `trs`: A `Tracks`object.
    + `time`: A `POSIXct` vector with the first element representing the start value of the respective time interval and the second element representing the end value of the respective time interval. The format is `"%Y-%m-%d"`.

* Value: 
    + An integer `vector` of the length equal the number of days within the time interval specified by `time` with `1` representing that at least one data point is available for a day and `0` that this is not the case.

```{r FixesForDays, eval = T, message = F, warning = F}
FixesForDays <- function(trs,
                        time
){
  
  # get Tracks data
  trs.df <- exDataTracks(trs)
  
  # get number of days within the time interval specified by time
  days <- difftime(time[2], time[1], units = "days")
  
  # get time interval
  time <- strftime(seq(from = time[1], to = time[2], by = 24*60*60), format = "%Y-%m-%d")
  
  print(days)
  
  # create vector to store results in
  fix.pres <- rep(0, days)
  
  # extract time information from trs
  trs.time <- unique(strftime(trs.df$time, format = "%Y-%m-%d"))
  
  # identify present data
  for(day_i in c(1:days)){
    
    if(time[day_i] %in% trs.time){
      fix.pres[day_i] <- 1
    }
    
  }
 
  # return result
  return(fix.pres)
   
}
```

## FixesForDaysTrColl

Function in order to identify the days within a specified time period, for which data points are available within all `Tracks` objects within a specified `TracksCollection` object. The function is a wrapper for `FixesForDays`

* Arguments:
    + `trscoll`: A `TracksCollection`object.
    + `time`: A `POSIXct` vector with the first element representing the start value of the respective time interval and the second element representing the end value of the respective time interval. The format is `"%Y-%m-%d"`.
    + `cores`: number of cores to use in parallel computing. Default is `cores = 1`.

* Value: 
    + An integer `vector` of the length equal the number of days within the time interval specified by `time` with `1` representing that at least one data point is available for a day and `0` that this is not the case.

* Issues:
    + Does not function yet.

```{r FixesForDaysTrColl, eval = T, message = F, warning = F}
FixesForDaysTrColl <- function(trscoll,
                               time,
                               cores = 1
){
  
  # load packages
  require("parallel")
  require("doParallel")
  
  # setup cluster
  cl <- makeCluster(cores, outfile="", type = "PSOCK")
  registerDoParallel(cl)
  clusterExport(cl = cl, varlist = list("exDataTracks", "FixesForDays", "trscoll"), envir=environment())
  
  fix.pres <- parLapply(cl, trscoll@tracksCollection, fun = function(x){FixesForDays(trs = x, time)})
 
  # stop cluster
  stopCluster(cl)
  
  # return result
  return(fix.pres)
   
}
```


